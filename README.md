# Руководство по использованию

# Постановка задачи первого этапа
Необходимо создать python-скрипт, принимающий в виде аргумента путь к *.jpg*/*.png*/*.pdf* файлу на выбор и проверяет, изображён ли на нём корректно заполненный документ или нет. Можно работать с любой из следующих форм: [*форма №1*](https://drive.google.com/file/d/1tj7hxhrnC9MAcHFFAvaugQrclcvCBptS/view?usp=sharing), [*форма №2*](https://drive.google.com/file/d/17jdyFcY1D7s4m7XHZfpKDEdZdWJq03nt/view?usp=sharing), [*форма №3*](https://drive.google.com/file/d/1rwl7lmPVMeR9lErPyNTX8Ka4HF3jC9T9/view?usp=sharing). В качестве усложнения задачи можно попоробовать создать программу под "текущую форму" (как мы поняли, пользователь загружает пустую форму и уже с ней ведётся сравнение).  
В случае, если в загруженном файле присутствовал корректно заполненный документ "достаточного качества", стоит вывести "ok", иначе - ничего не возвращать. Ошибка False Positive является гораздо большей проблемой, чем False Negative. Лучшее решение будет определяться по количеству допущенных ошибок.
# Решение
## Существующие проблемы
Для начала, стоит заметить, что данных предоставлено не так уж и много, следовательно стоит добыть дополнительные данные, на которых уже можно будет проверить работоспособность нашего скрипта.  
Первым этапом работы скрипта стоит сделать определение наличия или отсутствия документа на изображении - возможно, пользователь отправил нечто, не являющееся формой вообще.
В случае, если мы предполагаем что на изображении есть документ, необходимо его локализовать и приблизить, аналогично приложению Office Lense - подобное преобразование облегчит дальнейшую работу с документом.  
После того, как документ приближен, необходимо определить, является ли он нужным нам документом. Чтобы это понять, заметим, что печатные символы на документе являются своеобразным инвариантом и на их наличие можно полагаться. Мы можем попробовать рассчитать пересечение символов на исходном изображении, подвергнутом опенингу, и целевом изображении, также подвергнутом опенингу (опенинг в данном случае необходим, чтобы избавиться от узкого рукописного текста на целевом изображении; опенинг на исходном изображении - дабы трансформация текста в обоих документах была однородной).  
Затем можно определить, достаточного ли качества изображение. Этот путь мы назовём *путь A*. В данном случае нам каким-то образом надо определить "недостаточное" качество изображения. Стоит заметить, что это скорее всего будет неявно сделано на этапе определения корректности документа. Если же документ был признан корректным, но "качество" является плохим, можно предположить, что на долю изображения выпало мало пикселей. Стало быть, стоит попробовать найти некоторое пороговое значение *H\*W* для размера бланка на изображении, либо минимальный размер печатного символа. Это будет сделано "на глаз". Приуменьшить данное значение не так страшно, как преувеличить, так как False Positive опаснее False Negative и пересъёмка бланка пойдёт на пользу сотрудникам КД.
Далее необходимо определить, корректно ли заполнена форма. И тут возникает сразу несколько вариантов:
1. Определение "заполнено"/"не заполнено" (syntax check)
	- случай для определённого документа: можно заранее разметить зоны, где должны находиться записи;
	- случай "текущей формы": можно создать интуитивно понятный инструмент для разметки документа - в каких зонах должно быть что-то написно + установление простейших зависимостей (к примеру: должна быть черта "тут", "тут" или "тут"; если подчёркнуто это, то текст должен быть "тут", иначе - "там");
	- случай однородного батча данных (по одной форме): можно посмотреть на то, где обычно люди оставляют записи и значительные отклонения рассматривать как некорректно заполненную форму;
	- случай неоднородного батча данных (несколько форм): разбиение батча на однородный подбатчи методами кластеризации, последующее выполнение однородного батча.
2. Определение корректности заполненных данных (semantics check) - оно требует использования OCR  
	*стоит заметить, что использование OCR может привести к отказу от пути А - теперь документом в плохом качестве может считаться тот, рукописные символы на котором неразличимы*  
	- для "текущей формы" в дополнение к разметке документа можно добавить информацию о том, что должно находиться внутри каждой зоны: число (с возможностью указать длину и конкретные используемые цифры), слово или просто заполнение (для подчёркивания, скажем);
	- дополнительно, можно с каждым полем ассоциировать список значений - к примеру, паспорт может быть выдан лишь структурами с определёнными названиями. Если человеком введено некое "липовое" название, об этом стоит сообщить.

В случае, если документ прошёл все этапы, включая syntax/semantics check, можно сообщить о том, что документ заполнен корректно.
## Решение проблем
### Сбор данных
Для сбора данных мы воспользовались сервисом Яндекс.Толока, в качестве задания поставив заполнение одной из трёх данных форм. Участнику было необходимо отправить фотографии: пустой формы; с заполненными данными о ребёнке; + заполненными данными о родителе; + с проставленной датой; + с проставленной подписью. По итогу, нами было получено около пятисот фотографий/сканов документов, вероятно похожих на реальные изображения. Папку с данными можно найти [здесь](https://drive.google.com/drive/folders/1--T0b0AAmcDuBtn6WMy7RJavBs_yQ6nJ?usp=sharing). 
### Проверка наличия документа на изображении
#### Гистограммы яркости
Первоначальным предположением было следующее: на входном изображении для документа большую часть пикселей должна занимать белая бумага либо чёрные буквы. Чёрные буквы соответствуют низким значениям пикселей в ЧБ, белая бумага - высоким. Соответственно, нормализованная кумулятивная гистограмма должна иметь ступенчатый вид - первая "ступень" должна наблюдаться при низких значениях яркости (текст), вторая - при высоких значениях яркости (белвый лист). Нормализованные кумулятивные гистограммы же прочих изображений в среднем должны представлять из себя подобие равнобедренного треугольника. Соответственно, в связи с различием форм и планировалось определять, есть ли документ на изображении. Однако, к сожалению данный подход, хоть и был многообещающим, не смог принести соответствующие плоды - при подходящих нам значениях FP (~0.1%), значение FN поднималось до 30-40%, что нас абсолютно не устраивало. 
#### Квази-кватернионные методы
Как и было обещано в readme предыдущего проекта, мы попробовали удариться с головой в изучение кватернионов для computer vision и столкнулись с прекрасным вариантом использования qFT - разложение изображения на составляющие света и цвета (вольный перевод). Изображение света является rgb с равными значениями по всем значениям и при сложении с изображением возвращает исходное изображение. Данное разложение было реализовано нами, как поканальное вычитание значения `min(r, g, b)` для каждого пикселя.  
Изображения с документами должны быть почти не "цветными", тогда как обычные изображения должны быть цветными. Для оценки степени окрашенности изображения мы воспользовались L2 "окрашенности" изображения, делёного на площадь изображения. В поллу-псевдокоде это выглядит как `L2(img - img.min(axis = -1, keepdims = True)) / (img.shape[0] * img.shape[1])`. Данная формула оказалась прекрасным разделителем: все имеющиеся стоковые изображения имели значение > 0.09, тогда как изображения из Толоки имели значение < 0.07. Возможны проблемы на синтетичческих ЧБ данных, однако они будут исправлены в будушем. когда мы в качестве подстраховки добавим также информацию по гистограммам.
### Проверка сходства документов
#### Разметка документов
Для того, чтобы пользователь мог работать с новым документом, мы сделали небольшое приложение на Electron, позволяющее разметить на изображении поля/зоны, необходимые для заполнения. Также можно установить простейшую логику взаимодействий между полями. В дальнейшем будет немного доработан дизайн приложения, чтобы оно стало более user-friendly. 
#### Проверка соответствия документа 
Для того чтобы проверить, нужный ли документ был передан, используется наивное решение для поиска документа на изображении (в дальнейшем будет улучшено). Затем используется инвариант документа - зона с чёрными элементами (печатными). Считается IoU поданного и исходного документов, затем делается вывод о том, необходимый ли документ подан.
#### Проверка заполнения полей
Пока что не реализована (но скоро будет готова): по размеченной пользователем логике происходит проверка наличия записей в полях. Если все условия соблюдаются, документ считается корректно заполненным. Иначе - некорректно заполненным.
#### OCR
Также дополнительно планируется добавить возможность для каждого поля указывать базу возможных значений/символов, чтобы облегчить дальнейшую проверку данных. Через две недели данная задача в теории должна быть решена. 
## Распределение задач
Александр - получение данных из Толоки, попытка проверить соответствие документа
Даниил - проверка наличия документа, написание readme, продумывание общей структуры приложения
